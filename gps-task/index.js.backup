const express = require('express');
const mysql = require('mysql2/promise');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const multer = require('multer');
const path = require('path');

// JWT è¨­å®š
const JWT_SECRET = process.env.JWT_SECRET || 'gps-task-secret-key-change-in-production';
const JWT_EXPIRE = process.env.JWT_EXPIRE || '7d';

const app = express();

// CORS è¨­å®š - æ ¹æ“šç’°å¢ƒè®Šæ•¸é™åˆ¶ç¶²åŸŸ
const allowedOrigins = process.env.ALLOWED_ORIGINS
  ? process.env.ALLOWED_ORIGINS.split(',')
  : ['http://localhost:3000', 'http://localhost:3001', 'http://127.0.0.1:3000', 'http://127.0.0.1:3001'];

const corsOptions = {
  origin: (origin, callback) => {
    // å…è¨±æ²’æœ‰ origin çš„è«‹æ±‚ï¼ˆå¦‚ Postman æˆ– curlï¼‰
    if (!origin) return callback(null, true);

    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    } else {
      console.warn(`ğŸš« CORS é˜»æ“‹ä¾†æº: ${origin}`);
      return callback(new Error('Not allowed by CORS'), false);
    }
  },
  credentials: true, // å…è¨± cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400 // é æª¢è«‹æ±‚å¿«å– 24 å°æ™‚
};

app.use(cors(corsOptions));
app.use(cookieParser());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

const dbConfig = {
  host: 'localhost',
  user: 'root',
  password: '', // æœ¬åœ°MySQLé€šå¸¸ä¸éœ€è¦å¯†ç¢¼ï¼Œå¦‚æœæœ‰çš„è©±è«‹å¡«å…¥
  database: 'gps_task',
  port: 3306 // MySQLé»˜èªç«¯å£
};

// JWT å·¥å…·å‡½æ•¸
function generateToken(user) {
  return jwt.sign(
    {
      id: user.id,
      username: user.username,
      role: user.role
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRE }
  );
}

function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}

// JWT èªè­‰ä¸­é–“å±¤
function authenticateToken(req, res, next) {
  const token = req.cookies.token || req.headers.authorization?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ success: false, message: 'æœªæä¾›èªè­‰ä»¤ç‰Œ' });
  }

  const decoded = verifyToken(token);
  if (!decoded) {
    return res.status(401).json({ success: false, message: 'èªè­‰ä»¤ç‰Œç„¡æ•ˆæˆ–å·²éæœŸ' });
  }

  req.user = decoded;
  next();
}

// å…¼å®¹æ€§èªè­‰ä¸­é–“å±¤ - åŒæ™‚æ”¯æŒJWTå’Œè‡¨æ™‚ç”¨æˆ¶è³‡è¨Šï¼ˆç”¨æ–¼é·ç§»æœŸé–“ï¼‰
function authenticateTokenCompat(req, res, next) {
  // é¦–å…ˆå˜—è©¦JWTèªè­‰
  const token = req.cookies.token || req.headers.authorization?.replace('Bearer ', '');

  if (token) {
    const decoded = verifyToken(token);
    if (decoded) {
      req.user = decoded;
      return next();
    }
  }

  // å¦‚æœæ²’æœ‰JWT tokenï¼Œæª¢æŸ¥æ˜¯å¦æœ‰è‡¨æ™‚çš„ç”¨æˆ¶è³‡è¨Š
  const tempUser = req.headers['x-user-info'];
  if (tempUser) {
    try {
      const userInfo = JSON.parse(tempUser);
      if (userInfo && userInfo.id && userInfo.username && userInfo.role) {
        req.user = userInfo;
        return next();
      }
    } catch (e) {
      // è§£æå¤±æ•—ï¼Œç¹¼çºŒåˆ°éŒ¯èª¤è™•ç†
    }
  }

  return res.status(401).json({ success: false, message: 'æœªèªè­‰' });
}

// RBAC è§’è‰²æˆæ¬Šä¸­é–“å±¤
function requireRole(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ success: false, message: 'æœªèªè­‰' });
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'æ¬Šé™ä¸è¶³' });
    }

    next();
  };
}

// å®‰å…¨çš„æª”æ¡ˆä¸Šå‚³é…ç½®
const upload = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, path.join(__dirname, 'public/images'));
    },
    filename: (req, file, cb) => {
      // ç”Ÿæˆå®‰å…¨çš„æª”æ¡ˆåç¨±ï¼šæ™‚é–“æˆ³ + éš¨æ©Ÿå­—ä¸² + å‰¯æª”å
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      const extension = path.extname(file.originalname).toLowerCase();
      cb(null, uniqueSuffix + extension);
    }
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB é™åˆ¶
    files: 1 // ä¸€æ¬¡åªèƒ½ä¸Šå‚³ä¸€å€‹æª”æ¡ˆ
  },
  fileFilter: (req, file, cb) => {
    // å…è¨±çš„æª”æ¡ˆé¡å‹å’Œ MIME types
    const allowedTypes = [
      'image/jpeg',
      'image/jpg',
      'image/png',
      'image/gif',
      'image/webp'
    ];

    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];

    const fileExtension = path.extname(file.originalname).toLowerCase();

    // æª¢æŸ¥ MIME type å’Œå‰¯æª”å
    if (allowedTypes.includes(file.mimetype) && allowedExtensions.includes(fileExtension)) {
      cb(null, true);
    } else {
      cb(new Error('ä¸æ”¯æ´çš„æª”æ¡ˆé¡å‹ã€‚åªå…è¨± JPGã€PNGã€GIFã€WebP åœ–ç‰‡æª”æ¡ˆã€‚'), false);
    }
  }
});

app.post('/api/login', async (req, res) => {
  const { username, password, role } = req.body;
  if (!username || !role) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  }
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    if (role === 'user') {
      // æ‰‹æ©Ÿé–€è™Ÿç™»å…¥ - ä¸éœ€è¦å¯†ç¢¼é©—è­‰
      const [users] = await conn.execute('SELECT * FROM users WHERE username = ? AND role = ?', [username, 'user']);
      if (users.length === 0) {
        return res.status(400).json({ success: false, message: 'æŸ¥ç„¡æ­¤ç”¨æˆ¶' });
      }

      // ç”Ÿæˆ JWT token
      const token = generateToken(users[0]);

      // è¨­ç½® httpOnly cookie
      res.cookie('token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000
      });

      // è¿”å›ç”¨æˆ¶ä¿¡æ¯
      const userResponse = {
        id: users[0].id,
        username: users[0].username,
        role: users[0].role
      };

      res.json({ success: true, user: userResponse });
    } else if (role === 'staff' || role === 'shop' || role === 'admin') {
      // å¸³è™Ÿå¯†ç¢¼ç™»å…¥ - æ”¯æ´èˆŠçš„ 'staff' å’Œæ–°çš„ 'shop' è§’è‰²
      const [users] = await conn.execute('SELECT * FROM users WHERE username = ? AND role IN (?, ?, ?)', [username, 'staff', 'shop', 'admin']);
      if (users.length === 0) {
        return res.status(400).json({ success: false, message: 'æŸ¥ç„¡æ­¤å¸³è™Ÿ' });
      }

      const storedPassword = users[0].password;
      let match = false;

      // æ‰€æœ‰å¯†ç¢¼éƒ½å¿…é ˆæ˜¯ bcrypt hash æ ¼å¼
      if (storedPassword && (storedPassword.startsWith('$2a$') || storedPassword.startsWith('$2b$'))) {
        // ä½¿ç”¨ bcrypt æ¯”è¼ƒ
        match = await bcrypt.compare(password, storedPassword);
      } else {
        // å¯†ç¢¼æ ¼å¼éŒ¯èª¤æˆ–ç‚ºç©ºï¼Œæ‹’çµ•ç™»å…¥
        match = false;
        console.warn(`ç”¨æˆ¶ ${username} çš„å¯†ç¢¼æ ¼å¼ä¸æ­£ç¢º`);
      }

      if (!match) {
        return res.status(400).json({ success: false, message: 'å¯†ç¢¼éŒ¯èª¤' });
      }

      // ç”Ÿæˆ JWT token
      const token = generateToken(users[0]);

      // è¨­ç½® httpOnly cookie
      res.cookie('token', token, {
        httpOnly: true, // é˜²æ­¢ XSS æ”»æ“Š
        secure: process.env.NODE_ENV === 'production', // ç”Ÿç”¢ç’°å¢ƒä½¿ç”¨ HTTPS
        sameSite: 'strict', // é˜²æ­¢ CSRF æ”»æ“Š
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
      });

      // è¿”å›ç”¨æˆ¶ä¿¡æ¯ï¼ˆä¸åŒ…å«æ•æ„Ÿæ•¸æ“šï¼‰
      const userResponse = {
        id: users[0].id,
        username: users[0].username,
        role: users[0].role
      };

      res.json({ success: true, user: userResponse });
    } else {
      return res.status(400).json({ success: false, message: 'è§’è‰²éŒ¯èª¤' });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç™»å‡º API - æ¸…é™¤ JWT cookie
app.post('/api/logout', (req, res) => {
  res.clearCookie('token');
  res.json({ success: true, message: 'å·²æˆåŠŸç™»å‡º' });
});

// ç²å–ç•¶å‰ç”¨æˆ¶ä¿¡æ¯ API
app.get('/api/me', authenticateToken, (req, res) => {
  res.json({ success: true, user: req.user });
});


// QR Code API removed
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const couponId = req.params.id;

    // é©—è­‰å„ªæƒ åˆ¸å±¬æ–¼ç•¶å‰ç”¨æˆ¶
    const [coupons] = await conn.execute(
      'SELECT * FROM user_coupons WHERE id = ? AND user_id = ?',
      [couponId, req.user.id]
    );

    if (coupons.length === 0) {
      return res.status(404).json({ success: false, message: 'å„ªæƒ åˆ¸ä¸å­˜åœ¨' });
    }

    const coupon = coupons[0];

    if (coupon.is_used) {
      return res.status(400).json({ success: false, message: 'å„ªæƒ åˆ¸å·²ä½¿ç”¨' });
    }

    if (new Date(coupon.expiry_date) < new Date()) {
      return res.status(400).json({ success: false, message: 'å„ªæƒ åˆ¸å·²éæœŸ' });
    }

    // ç”ŸæˆQRç¢¼å…§å®¹
    const qrData = JSON.stringify({
      couponId: coupon.id,
      couponCode: coupon.coupon_code,
      userId: req.user.id,
      timestamp: Date.now()
    });

    // ç”ŸæˆQRç¢¼
    const qrCodeDataURL = await QRCode.toDataURL(qrData, {
      width: 256,
      margin: 2,
      color: {
        dark: '#000000',
        light: '#FFFFFF'
      }
    });

    res.json({ success: true, qrCode: qrCodeDataURL, coupon });
  } catch (err) {
    console.error('ç”ŸæˆQRç¢¼å¤±æ•—:', err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æ ¹æ“šå„ªæƒ åˆ¸ä»£ç¢¼æŸ¥è©¢å„ªæƒ åˆ¸ï¼ˆå•†å®¶æ ¸éŠ·ç”¨ï¼‰
app.get('/api/coupons/lookup/:code', authenticateToken, requireRole('shop', 'admin'), async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const couponCode = req.params.code;

    // æŸ¥è©¢å„ªæƒ åˆ¸åŠç”¨æˆ¶ä¿¡æ¯
    const [coupons] = await conn.execute(
      'SELECT uc.*, u.username FROM user_coupons uc JOIN users u ON uc.user_id = u.id WHERE uc.coupon_code = ?',
      [couponCode]
    );

    if (coupons.length === 0) {
      return res.status(404).json({ success: false, message: 'æ‰¾ä¸åˆ°æ­¤å„ªæƒ åˆ¸' });
    }

    res.json({ success: true, coupon: coupons[0] });
  } catch (err) {
    console.error('æŸ¥è©¢å„ªæƒ åˆ¸å¤±æ•—:', err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å•†å®¶æ ¸éŠ·å„ªæƒ åˆ¸
app.post('/api/coupons/:id/redeem', authenticateToken, requireRole('shop', 'admin'), async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    await conn.beginTransaction();

    const couponId = req.params.id;

    // ç²å–å„ªæƒ åˆ¸ä¿¡æ¯
    const [coupons] = await conn.execute(
      'SELECT * FROM user_coupons WHERE id = ?',
      [couponId]
    );

    if (coupons.length === 0) {
      await conn.rollback();
      return res.status(404).json({ success: false, message: 'å„ªæƒ åˆ¸ä¸å­˜åœ¨' });
    }

    const coupon = coupons[0];

    if (coupon.is_used) {
      await conn.rollback();
      return res.status(400).json({ success: false, message: 'å„ªæƒ åˆ¸å·²ä½¿ç”¨' });
    }

    if (new Date(coupon.expiry_date) < new Date()) {
      await conn.rollback();
      return res.status(400).json({ success: false, message: 'å„ªæƒ åˆ¸å·²éæœŸ' });
    }

    // æ ¸éŠ·å„ªæƒ åˆ¸
    await conn.execute(
      'UPDATE user_coupons SET is_used = TRUE, used_at = NOW() WHERE id = ?',
      [couponId]
    );

    await conn.commit();

    res.json({
      success: true,
      message: 'å„ªæƒ åˆ¸æ ¸éŠ·æˆåŠŸ',
      coupon: {
        ...coupon,
        is_used: true,
        used_at: new Date()
      }
    });
  } catch (err) {
    if (conn) await conn.rollback();
    console.error('æ ¸éŠ·å„ªæƒ åˆ¸å¤±æ•—:', err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç²å–ä»Šæ—¥æ ¸éŠ·æ­·å²ï¼ˆå•†å®¶ç”¨ï¼‰
app.get('/api/coupons/redeem-history', authenticateToken, requireRole('shop', 'admin'), async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);

    // ç²å–ä»Šæ—¥æ ¸éŠ·è¨˜éŒ„
    const today = new Date().toISOString().split('T')[0];
    const [history] = await conn.execute(
      `SELECT uc.coupon_code, uc.title as coupon_title, u.username, uc.used_at
       FROM user_coupons uc
       JOIN users u ON uc.user_id = u.id
       WHERE uc.is_used = TRUE
       AND DATE(uc.used_at) = ?
       ORDER BY uc.used_at DESC`,
      [today]
    );

    res.json({ success: true, history });
  } catch (err) {
    console.error('ç²å–æ ¸éŠ·æ­·å²å¤±æ•—:', err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å‰µå»ºå„ªæƒ åˆ¸ï¼ˆä»»å‹™å®Œæˆå¾Œè‡ªå‹•èª¿ç”¨ï¼‰
app.post('/api/coupons/create', authenticateToken, requireRole('shop', 'admin'), async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const { userId, title, description, discountAmount, expiryDays } = req.body;

    if (!userId || !title) {
      return res.status(400).json({ success: false, message: 'ç¼ºå°‘å¿…è¦åƒæ•¸' });
    }

    // ç”Ÿæˆå„ªæƒ åˆ¸ä»£ç¢¼
    const couponCode = 'TASK' + Date.now() + Math.random().toString(36).substr(2, 5).toUpperCase();

    // è¨ˆç®—åˆ°æœŸæ—¥æœŸ
    const expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + (expiryDays || 30));

    await conn.execute(
      'INSERT INTO user_coupons (user_id, coupon_code, title, description, discount_amount, expiry_date) VALUES (?, ?, ?, ?, ?, ?)',
      [userId, couponCode, title, description || '', discountAmount || 0, expiryDate.toISOString().split('T')[0]]
    );

    res.json({ success: true, message: 'å„ªæƒ åˆ¸å‰µå»ºæˆåŠŸ', couponCode });
  } catch (err) {
    console.error('å‰µå»ºå„ªæƒ åˆ¸å¤±æ•—:', err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

app.post('/api/register', async (req, res) => {
  const { username, password, role } = req.body;
  if (!username || !role) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  }
  if (role === 'user') {
    // æ‰‹æ©Ÿé–€è™Ÿè¨»å†Šï¼Œä¸éœ€å¯†ç¢¼
    if (!/^09[0-9]{8}$/.test(username)) {
      return res.status(400).json({ success: false, message: 'è«‹è¼¸å…¥æ­£ç¢ºçš„æ‰‹æ©Ÿé–€è™Ÿ' });
    }
  } else if (role === 'staff' || role === 'admin') {
    if (!password) {
      return res.status(400).json({ success: false, message: 'è«‹å¡«å¯«å¯†ç¢¼' });
    }
  } else {
    return res.status(400).json({ success: false, message: 'è§’è‰²éŒ¯èª¤' });
  }
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // æª¢æŸ¥å¸³è™Ÿæ˜¯å¦å·²å­˜åœ¨
    const [exist] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (exist.length > 0) {
      return res.status(400).json({ success: false, message: 'å¸³è™Ÿå·²å­˜åœ¨' });
    }
    // å¯«å…¥è³‡æ–™åº«
    await conn.execute(
      'INSERT INTO users (username, password, role) VALUES (?, ?, ?)',
      [username, password || null, role]
    );
    res.json({ success: true, message: 'è¨»å†ŠæˆåŠŸ' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æŸ¥è©¢æ‰€æœ‰ä»»å‹™
// ç²å–ä»»å‹™ï¼ˆå‰ç«¯ç”¨ï¼‰
app.get('/api/tasks', async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const [rows] = await conn.execute('SELECT * FROM tasks WHERE 1=1 ORDER BY id DESC');
    res.json({ success: true, tasks: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç²å–ä»»å‹™ï¼ˆç®¡ç†å¾Œå°ç”¨ï¼Œæ ¹æ“šç”¨æˆ¶è§’è‰²ç¯©é¸ï¼‰
app.get('/api/tasks/admin', authenticateToken, requireRole('shop', 'admin'), async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.user.username;
    const userRole = req.user.role;

    let query, params;

    if (userRole === 'admin') {
      // ç®¡ç†å“¡å¯ä»¥çœ‹åˆ°æ‰€æœ‰ä»»å‹™
      query = 'SELECT * FROM tasks ORDER BY id DESC';
      params = [];
    } else {
      // å•†åº—åªèƒ½çœ‹åˆ°è‡ªå·±å‰µå»ºçš„ä»»å‹™
      query = 'SELECT * FROM tasks WHERE created_by = ? ORDER BY id DESC';
      params = [username];
    }

    const [rows] = await conn.execute(query, params);
    res.json({ success: true, tasks: rows, userRole });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æ–°å¢ä»»å‹™
app.post('/api/tasks', staffOrAdminAuth, async (req, res) => {
  const { name, lat, lng, radius, description, photoUrl, youtubeUrl, points } = req.body;
  if (!name || !lat || !lng || !radius || !description || !photoUrl) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];
    const pts = Number(points) || 0;

    await conn.execute(
      'INSERT INTO tasks (name, lat, lng, radius, description, photoUrl, iconUrl, youtubeUrl, points, created_by) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [name, lat, lng, radius, description, photoUrl, '/images/flag-red.png', youtubeUrl || null, pts, username]
    );
    res.json({ success: true, message: 'æ–°å¢æˆåŠŸ' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å®‰å…¨çš„æª”æ¡ˆä¸Šå‚³ API
app.post('/api/upload', authenticateToken, requireRole('shop', 'admin'), (req, res) => {
  // ä½¿ç”¨ multer ä¸­é–“å±¤è™•ç†æª”æ¡ˆä¸Šå‚³
  upload.single('photo')(req, res, (err) => {
    if (err) {
      // è™•ç†ä¸Šå‚³éŒ¯èª¤
      if (err instanceof multer.MulterError) {
        if (err.code === 'LIMIT_FILE_SIZE') {
          return res.status(400).json({ success: false, message: 'æª”æ¡ˆå¤§å°è¶…é 5MB é™åˆ¶' });
        }
        if (err.code === 'LIMIT_FILE_COUNT') {
          return res.status(400).json({ success: false, message: 'ä¸€æ¬¡åªèƒ½ä¸Šå‚³ä¸€å€‹æª”æ¡ˆ' });
        }
      }

      // è™•ç†è‡ªå®šç¾©éŒ¯èª¤ï¼ˆæª”æ¡ˆé¡å‹ä¸æ”¯æ´ï¼‰
      if (err.message.includes('ä¸æ”¯æ´çš„æª”æ¡ˆé¡å‹')) {
        return res.status(400).json({ success: false, message: err.message });
      }

      // å…¶ä»–éŒ¯èª¤
      console.error('æª”æ¡ˆä¸Šå‚³éŒ¯èª¤:', err);
      return res.status(500).json({ success: false, message: 'æª”æ¡ˆä¸Šå‚³å¤±æ•—' });
    }

    if (!req.file) {
      return res.status(400).json({ success: false, message: 'æœªé¸æ“‡æª”æ¡ˆ' });
    }

    // å›å‚³å®‰å…¨çš„åœ–ç‰‡è·¯å¾‘ï¼ˆä½¿ç”¨æ–°çš„æª”æ¡ˆåç¨±ï¼‰
    const imageUrl = '/images/' + req.file.filename;
    console.log(`âœ… æª”æ¡ˆä¸Šå‚³æˆåŠŸ: ${req.file.originalname} -> ${req.file.filename}`);
    res.json({ success: true, url: imageUrl, filename: req.file.filename });
  });
});

// æŸ¥è©¢ç›®å‰ç™»å…¥è€…é€²è¡Œä¸­çš„ä»»å‹™ï¼ˆéœ€å‚³ usernameï¼‰
app.get('/api/user-tasks', async (req, res) => {
  const { username } = req.query;
  if (!username) return res.status(400).json({ success: false, message: 'ç¼ºå°‘ username' });
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // å–å¾— user_id
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) return res.json({ success: true, tasks: [] });
    const userId = users[0].id;
    // æŸ¥è©¢é€²è¡Œä¸­ä»»å‹™
    const [rows] = await conn.execute(
      `SELECT t.*, ut.status, ut.started_at, ut.finished_at, ut.id as user_task_id
       FROM user_tasks ut
       JOIN tasks t ON ut.task_id = t.id
       WHERE ut.user_id = ? AND ut.status = 'é€²è¡Œä¸­'`,
      [userId]
    );
    res.json({ success: true, tasks: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// åŠ å…¥ä»»å‹™ï¼ˆéœ€å‚³ username, task_idï¼‰
app.post('/api/user-tasks', async (req, res) => {
  const { username, task_id } = req.body;
  if (!username || !task_id) return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // å–å¾— user_id
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) return res.status(400).json({ success: false, message: 'æ‰¾ä¸åˆ°ä½¿ç”¨è€…' });
    const userId = users[0].id;
    // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰é€²è¡Œä¸­
    const [inProgress] = await conn.execute('SELECT id FROM user_tasks WHERE user_id = ? AND task_id = ? AND status = "é€²è¡Œä¸­"', [userId, task_id]);
    if (inProgress.length > 0) return res.json({ success: true, message: 'å·²åœ¨é€²è¡Œä¸­' });

    // æª¢æŸ¥æ˜¯å¦å·²ç¶“å®Œæˆé
    const [completed] = await conn.execute('SELECT id FROM user_tasks WHERE user_id = ? AND task_id = ? AND status = "å®Œæˆ"', [userId, task_id]);
    if (completed.length > 0) return res.json({ success: false, message: 'æ­¤ä»»å‹™å·²å®Œæˆéï¼Œç„¡æ³•å†æ¬¡æ¥å–' });

    await conn.execute('INSERT INTO user_tasks (user_id, task_id, status) VALUES (?, ?, "é€²è¡Œä¸­")', [userId, task_id]);
    res.json({ success: true, message: 'å·²åŠ å…¥ä»»å‹™' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å®Œæˆä»»å‹™ï¼ˆéœ€å‚³ username, task_idï¼‰
app.post('/api/user-tasks/finish', async (req, res) => {
  const { username, task_id } = req.body;
  if (!username || !task_id) return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);

    // å–å¾— user_id
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) return res.status(400).json({ success: false, message: 'æ‰¾ä¸åˆ°ä½¿ç”¨è€…' });
    const userId = users[0].id;

    // å–å¾—ä»»å‹™è³‡è¨Š
    const [tasks] = await conn.execute('SELECT name, points FROM tasks WHERE id = ?', [task_id]);
    if (tasks.length === 0) return res.status(400).json({ success: false, message: 'æ‰¾ä¸åˆ°ä»»å‹™' });
    const task = tasks[0];

    // é–‹å§‹äº¤æ˜“
    await conn.beginTransaction();

    try {
      // æ›´æ–°ä»»å‹™ç‹€æ…‹ç‚ºå®Œæˆ
      await conn.execute('UPDATE user_tasks SET status = "å®Œæˆ", finished_at = NOW() WHERE user_id = ? AND task_id = ? AND status = "é€²è¡Œä¸­"', [userId, task_id]);

      // è¨˜éŒ„ç©åˆ†ç²å¾—äº¤æ˜“
      if (task.points > 0) {
        await conn.execute(
          'INSERT INTO point_transactions (user_id, type, points, description, reference_type, reference_id) VALUES (?, ?, ?, ?, ?, ?)',
          [userId, 'earned', task.points, `å®Œæˆä»»å‹™: ${task.name}`, 'task_completion', task_id]
        );
      }

      await conn.commit();
      res.json({ success: true, message: `å·²å®Œæˆä»»å‹™ï¼Œç²å¾— ${task.points} ç©åˆ†ï¼` });

    } catch (err) {
      await conn.rollback();
      throw err;
    }

  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æŸ¥è©¢å–®ä¸€ä»»å‹™
app.get('/api/tasks/:id', async (req, res) => {
  const { id } = req.params;
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const [rows] = await conn.execute('SELECT * FROM tasks WHERE id = ?', [id]);
    if (rows.length === 0) return res.status(404).json({ success: false, message: 'æ‰¾ä¸åˆ°ä»»å‹™' });
    res.json({ success: true, task: rows[0] });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç·¨è¼¯ä»»å‹™
app.put('/api/tasks/:id', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  const { name, lat, lng, radius, description, photoUrl, youtubeUrl, points } = req.body;
  if (!name || !lat || !lng || !radius || !description || !photoUrl) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘åƒæ•¸' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;

    // æª¢æŸ¥ä»»å‹™æ˜¯å¦å­˜åœ¨ï¼Œä¸¦ç¢ºèªæ¬Šé™
    let taskQuery, taskParams;
    if (userRole === 'admin') {
      taskQuery = 'SELECT id FROM tasks WHERE id = ?';
      taskParams = [id];
    } else {
      taskQuery = 'SELECT id FROM tasks WHERE id = ? AND created_by = ?';
      taskParams = [id, username];
    }

    const [taskRows] = await conn.execute(taskQuery, taskParams);
    if (taskRows.length === 0) {
      return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™ç·¨è¼¯æ­¤ä»»å‹™' });
    }

    const pts = Number(points) || 0;
    await conn.execute(
      'UPDATE tasks SET name=?, lat=?, lng=?, radius=?, description=?, photoUrl=?, youtubeUrl=?, points=? WHERE id=?',
      [name, lat, lng, radius, description, photoUrl, youtubeUrl || null, pts, id]
    );
    res.json({ success: true, message: 'æ›´æ–°æˆåŠŸ' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// åˆªé™¤ä»»å‹™
app.delete('/api/tasks/:id', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;

    // æª¢æŸ¥ä»»å‹™æ˜¯å¦å­˜åœ¨ï¼Œä¸¦ç¢ºèªæ¬Šé™
    let taskQuery, taskParams;
    if (userRole === 'admin') {
      taskQuery = 'SELECT id FROM tasks WHERE id = ?';
      taskParams = [id];
    } else {
      taskQuery = 'SELECT id FROM tasks WHERE id = ? AND created_by = ?';
      taskParams = [id, username];
    }

    const [taskRows] = await conn.execute(taskQuery, taskParams);
    if (taskRows.length === 0) {
      return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™åˆªé™¤æ­¤ä»»å‹™' });
    }

    // å…ˆåˆªé™¤ç›¸é—œçš„ä½¿ç”¨è€…ä»»å‹™è¨˜éŒ„
    await conn.execute('DELETE FROM user_tasks WHERE task_id = ?', [id]);
    // å†åˆªé™¤ä»»å‹™æœ¬èº«
    await conn.execute('DELETE FROM tasks WHERE id = ?', [id]);
    res.json({ success: true, message: 'å·²åˆªé™¤' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ====== Rank è¨ˆç®—å·¥å…· ======
function getRank(started, finished) {
  if (!started || !finished) return '';
  // è½‰ç‚ºå°ç£æ™‚å€
  const startedTW = new Date(new Date(started).getTime() + 8 * 60 * 60 * 1000);
  const finishedTW = new Date(new Date(finished).getTime() + 8 * 60 * 60 * 1000);
  const diff = (finishedTW - startedTW) / 3600000;
  if (diff <= 1) return 'S+';
  if (diff <= 2) return 'S';
  if (diff <= 3) return 'A';
  if (diff <= 4) return 'B';
  if (diff <= 5) return 'C';
  if (diff <= 6) return 'D';
  return 'E';
}

// æŸ¥è©¢æ‰€æœ‰ï¼ˆé€²è¡Œä¸­ï¼‹å®Œæˆï¼‰ä»»å‹™
app.get('/api/user-tasks/all', async (req, res) => {
  const { username } = req.query;
  if (!username) return res.status(400).json({ success: false, message: 'ç¼ºå°‘ username' });
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // å–å¾— user_id
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) return res.json({ success: true, tasks: [] });
    const userId = users[0].id;
    // æŸ¥è©¢æ‰€æœ‰ä»»å‹™
    const [rows] = await conn.execute(
      `SELECT t.*, ut.status, ut.started_at, ut.finished_at, ut.id as user_task_id, ut.redeemed, ut.redeemed_at, ut.redeemed_by, ut.answer
       FROM user_tasks ut
       JOIN tasks t ON ut.task_id = t.id
       WHERE ut.user_id = ?
       ORDER BY ut.started_at DESC`,
      [userId]
    );
    // åŠ  rank
    const tasks = rows.map(row => ({
      ...row,
      rank: getRank(row.started_at, row.finished_at)
    }));
    res.json({ success: true, tasks });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ===== Admin æ¬Šé™é©—è­‰ä¸­ä»‹å±¤ =====
function adminAuth(req, res, next) {
  const username = req.headers['x-username'];
  if (!username) return res.status(401).json({ success: false, message: 'æœªç™»å…¥' });
  mysql.createConnection(dbConfig).then(conn => {
    conn.execute('SELECT role FROM users WHERE username = ?', [username])
      .then(([rows]) => {
        conn.end();
        if (rows.length === 0 || rows[0].role !== 'admin') {
          return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™' });
        }
        next();
      })
      .catch(err => {
        conn.end();
        res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
      });
  });
}

// ===== Staff æˆ– Admin æ¬Šé™é©—è­‰ä¸­ä»‹å±¤ =====
// èˆŠçš„ä¸­é–“å±¤ - ç‚ºäº†å‘å¾Œå…¼å®¹ä¿ç•™ï¼Œä½†å»ºè­°ä½¿ç”¨æ–°çš„ JWT ä¸­é–“å±¤
function staffOrAdminAuth(req, res, next) {
  const username = req.headers['x-username'];
  if (!username) return res.status(401).json({ success: false, message: 'æœªç™»å…¥' });
  mysql.createConnection(dbConfig).then(conn => {
    conn.execute('SELECT role FROM users WHERE username = ?', [username])
      .then(([rows]) => {
        conn.end();
        if (rows.length === 0 || (rows[0].role !== 'shop' && rows[0].role !== 'admin')) {
          return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™' });
        }
        next();
      })
      .catch(err => {
        conn.end();
        res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
      });
  });
}

// ===== Staff å…Œæ›ä»»å‹™çå‹µ =====
app.post('/api/user-tasks/:id/redeem', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  const staffUser = req.headers['x-username'];
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // åªèƒ½å…Œæ›å·²å®Œæˆä¸”æœªå…Œæ›çš„
    const [rows] = await conn.execute('SELECT * FROM user_tasks WHERE id = ? AND status = "å®Œæˆ" AND redeemed = 0', [id]);
    if (rows.length === 0) return res.status(400).json({ success: false, message: 'ä¸å¯é‡è¤‡å…Œæ›æˆ–å°šæœªå®Œæˆ' });
    await conn.execute('UPDATE user_tasks SET redeemed = 1, redeemed_at = NOW(), redeemed_by = ? WHERE id = ?', [staffUser, id]);
    res.json({ success: true, message: 'å·²å…Œæ›' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ===== Staff æŸ¥è©¢æ‰€æœ‰é€²è¡Œä¸­ä»»å‹™ï¼ˆå¯æœå°‹ï¼‰ =====
app.get('/api/user-tasks/in-progress', staffOrAdminAuth, async (req, res) => {
  const { taskName, username } = req.query;
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const reqUsername = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [reqUsername]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;
    let sql = `SELECT ut.id as user_task_id, ut.user_id, ut.task_id, ut.status, ut.started_at, ut.finished_at, ut.redeemed, ut.redeemed_at, ut.redeemed_by, ut.answer, u.username, t.name as task_name, t.description, t.points, t.created_by as task_creator
      FROM user_tasks ut
      JOIN users u ON ut.user_id = u.id
      JOIN tasks t ON ut.task_id = t.id
      WHERE ut.status = 'é€²è¡Œä¸­'`;
    const params = [];

    if (userRole === 'staff') {
      // å·¥ä½œäººå“¡åªèƒ½çœ‹åˆ°è‡ªå·±å‰µå»ºçš„ä»»å‹™çš„é€²è¡Œä¸­è¨˜éŒ„
      sql += ' AND t.created_by = ?';
      params.push(reqUsername);
    }

    if (taskName) {
      sql += ' AND t.name LIKE ?';
      params.push('%' + taskName + '%');
    }
    if (username) {
      sql += ' AND u.username LIKE ?';
      params.push('%' + username + '%');
    }
    sql += ' ORDER BY ut.started_at DESC';
    const [rows] = await conn.execute(sql, params);
    res.json({ success: true, tasks: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ===== Staff æŸ¥è©¢æ‰€æœ‰å·²å®Œæˆä½†æœªå…Œæ›çš„ä»»å‹™ï¼ˆå¯æœå°‹ï¼‰ =====
app.get('/api/user-tasks/to-redeem', staffOrAdminAuth, async (req, res) => {
  const { taskName, username } = req.query;
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const reqUsername = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [reqUsername]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;
    let sql = `SELECT ut.id as user_task_id, ut.user_id, ut.task_id, ut.status, ut.started_at, ut.finished_at, ut.redeemed, ut.redeemed_at, ut.redeemed_by, u.username, t.name as task_name, t.description, t.points, t.created_by as task_creator
      FROM user_tasks ut
      JOIN users u ON ut.user_id = u.id
      JOIN tasks t ON ut.task_id = t.id
      WHERE ut.status = 'å®Œæˆ' AND ut.redeemed = 0`;
    const params = [];

    if (userRole === 'staff') {
      // å·¥ä½œäººå“¡åªèƒ½çœ‹åˆ°è‡ªå·±å‰µå»ºçš„ä»»å‹™çš„å·²å®Œæˆè¨˜éŒ„
      sql += ' AND t.created_by = ?';
      params.push(reqUsername);
    }

    if (taskName) {
      sql += ' AND t.name LIKE ?';
      params.push('%' + taskName + '%');
    }
    if (username) {
      sql += ' AND u.username LIKE ?';
      params.push('%' + username + '%');
    }
    sql += ' ORDER BY ut.finished_at DESC';
    const [rows] = await conn.execute(sql, params);
    res.json({ success: true, tasks: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å„²å­˜/æ›´æ–°çŒœè¬ç­”æ¡ˆ
app.patch('/api/user-tasks/:id/answer', async (req, res) => {
  const { id } = req.params;
  const { answer } = req.body;
  if (!answer) return res.status(400).json({ success: false, message: 'ç¼ºå°‘ç­”æ¡ˆ' });
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    await conn.execute('UPDATE user_tasks SET answer = ? WHERE id = ?', [answer, id]);
    res.json({ success: true, message: 'ç­”æ¡ˆå·²å„²å­˜' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ===== å•†å“ç®¡ç† API =====

// ç²å–æ‰€æœ‰å•†å“ï¼ˆç”¨æˆ¶ç”¨ï¼‰
app.get('/api/products', async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const [rows] = await conn.execute(`
      SELECT p.*, u.username as creator_username
      FROM products p
      LEFT JOIN users u ON p.created_by = u.username
      WHERE p.is_active = TRUE
      ORDER BY p.points_required ASC
    `);
    res.json({ success: true, products: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç²å–æ‰€æœ‰å•†å“ï¼ˆç®¡ç†å“¡ç”¨ï¼‰- æ ¹æ“šç”¨æˆ¶è§’è‰²ç¯©é¸
app.get('/api/products/admin', staffOrAdminAuth, async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;
    let query, params;

    if (userRole === 'admin') {
      // ç®¡ç†å“¡å¯ä»¥çœ‹åˆ°æ‰€æœ‰å•†å“
      query = 'SELECT * FROM products ORDER BY created_at DESC';
      params = [];
    } else {
      // å·¥ä½œäººå“¡åªèƒ½çœ‹åˆ°è‡ªå·±å‰µå»ºçš„å•†å“
      query = 'SELECT * FROM products WHERE created_by = ? ORDER BY created_at DESC';
      params = [username];
    }

    const [rows] = await conn.execute(query, params);
    res.json({ success: true, products: rows, userRole });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æ–°å¢å•†å“
app.post('/api/products', staffOrAdminAuth, async (req, res) => {
  const { name, description, image_url, points_required, stock } = req.body;
  if (!name || !points_required || stock === undefined) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘å¿…è¦åƒæ•¸' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    const [result] = await conn.execute(
      'INSERT INTO products (name, description, image_url, points_required, stock, created_by) VALUES (?, ?, ?, ?, ?, ?)',
      [name, description || '', image_url || '', points_required, stock, username]
    );
    res.json({ success: true, message: 'å•†å“æ–°å¢æˆåŠŸ', productId: result.insertId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç·¨è¼¯å•†å“
app.put('/api/products/:id', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  const { name, description, image_url, points_required, stock, is_active } = req.body;
  if (!name || !points_required || stock === undefined) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘å¿…è¦åƒæ•¸' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;

    // æª¢æŸ¥å•†å“æ˜¯å¦å­˜åœ¨ï¼Œä¸¦ç¢ºèªæ¬Šé™
    let productQuery, productParams;
    if (userRole === 'admin') {
      productQuery = 'SELECT id FROM products WHERE id = ?';
      productParams = [id];
    } else {
      productQuery = 'SELECT id FROM products WHERE id = ? AND created_by = ?';
      productParams = [id, username];
    }

    const [productRows] = await conn.execute(productQuery, productParams);
    if (productRows.length === 0) {
      return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™ç·¨è¼¯æ­¤å•†å“' });
    }

    await conn.execute(
      'UPDATE products SET name = ?, description = ?, image_url = ?, points_required = ?, stock = ?, is_active = ? WHERE id = ?',
      [name, description || '', image_url || '', points_required, stock, is_active !== undefined ? is_active : true, id]
    );
    res.json({ success: true, message: 'å•†å“æ›´æ–°æˆåŠŸ' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// åˆªé™¤å•†å“
app.delete('/api/products/:id', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;

    // æª¢æŸ¥å•†å“æ˜¯å¦å­˜åœ¨ï¼Œä¸¦ç¢ºèªæ¬Šé™
    let productQuery, productParams;
    if (userRole === 'admin') {
      productQuery = 'SELECT id FROM products WHERE id = ?';
      productParams = [id];
    } else {
      productQuery = 'SELECT id FROM products WHERE id = ? AND created_by = ?';
      productParams = [id, username];
    }

    const [productRows] = await conn.execute(productQuery, productParams);
    if (productRows.length === 0) {
      return res.status(403).json({ success: false, message: 'ç„¡æ¬Šé™åˆªé™¤æ­¤å•†å“' });
    }

    await conn.execute(
      'DELETE FROM products WHERE id = ?',
      [id]
    );
    res.json({ success: true, message: 'å•†å“åˆªé™¤æˆåŠŸ' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç²å–ç”¨æˆ¶çš„å•†å“å…Œæ›è¨˜éŒ„
app.get('/api/products/redemptions', async (req, res) => {
  const username = req.headers['x-username'];
  if (!username) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘ç”¨æˆ¶åç¨±' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    // ç²å–ç”¨æˆ¶ID
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) {
      return res.status(400).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }
    const userId = users[0].id;

    // ç²å–å…Œæ›è¨˜éŒ„
    const [rows] = await conn.execute(`
      SELECT pr.*, p.name as product_name, p.image_url
      FROM product_redemptions pr
      JOIN products p ON pr.product_id = p.id
      WHERE pr.user_id = ?
      ORDER BY pr.redeemed_at DESC
    `, [userId]);

    res.json({ success: true, redemptions: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// å…Œæ›å•†å“
app.post('/api/products/:id/redeem', async (req, res) => {
  const { id } = req.params;
  const username = req.headers['x-username'];
  if (!username) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘ç”¨æˆ¶åç¨±' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);

    // ç²å–ç”¨æˆ¶ID
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) {
      return res.status(400).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }
    const userId = users[0].id;

    // ç²å–å•†å“è³‡è¨Š
    const [products] = await conn.execute('SELECT * FROM products WHERE id = ? AND is_active = TRUE', [id]);
    if (products.length === 0) {
      return res.status(400).json({ success: false, message: 'å•†å“ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶' });
    }
    const product = products[0];

    // æª¢æŸ¥åº«å­˜
    if (product.stock <= 0) {
      return res.status(400).json({ success: false, message: 'å•†å“å·²å”®å®Œ' });
    }

    // è¨ˆç®—ç”¨æˆ¶ç¸½ç©åˆ†ï¼ˆç²å¾—ç©åˆ† - æ¶ˆè²»ç©åˆ†ï¼‰
    const [userPointsResult] = await conn.execute(`
      SELECT
        COALESCE(SUM(CASE WHEN type = 'earned' THEN points ELSE 0 END), 0) -
        COALESCE(SUM(CASE WHEN type = 'spent' THEN points ELSE 0 END), 0) as total_points
      FROM point_transactions
      WHERE user_id = ?
    `, [userId]);

    const totalPoints = userPointsResult[0].total_points || 0;

    // æª¢æŸ¥ç©åˆ†æ˜¯å¦è¶³å¤ 
    if (totalPoints < product.points_required) {
      return res.status(400).json({ success: false, message: `ç©åˆ†ä¸è¶³ï¼Œéœ€è¦ ${product.points_required} ç©åˆ†ï¼Œæ‚¨ç›®å‰æœ‰ ${totalPoints} ç©åˆ†` });
    }

    // é–‹å§‹äº¤æ˜“
    await conn.beginTransaction();

    try {
      // æ¸›å°‘åº«å­˜
      await conn.execute('UPDATE products SET stock = stock - 1 WHERE id = ?', [id]);

      // è¨˜éŒ„å…Œæ›
      const [redemptionResult] = await conn.execute(
        'INSERT INTO product_redemptions (user_id, product_id, points_used, status) VALUES (?, ?, ?, ?)',
        [userId, id, product.points_required, 'pending']
      );

      // è¨˜éŒ„ç©åˆ†æ‰£é™¤äº¤æ˜“
      await conn.execute(
        'INSERT INTO point_transactions (user_id, type, points, description, reference_type, reference_id) VALUES (?, ?, ?, ?, ?, ?)',
        [userId, 'spent', product.points_required, `å…Œæ›å•†å“: ${product.name}`, 'product_redemption', redemptionResult.insertId]
      );

      await conn.commit();
      res.json({ success: true, message: 'å•†å“å…Œæ›æˆåŠŸï¼è«‹ç­‰å¾…å·¥ä½œäººå“¡ç¢ºèªã€‚' });

    } catch (err) {
      await conn.rollback();
      throw err;
    }

  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ç²å–ç”¨æˆ¶ç¸½ç©åˆ†
app.get('/api/user/points', async (req, res) => {
  const username = req.headers['x-username'];
  if (!username) {
    return res.status(400).json({ success: false, message: 'ç¼ºå°‘ç”¨æˆ¶åç¨±' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);

    // ç²å–ç”¨æˆ¶ID
    const [users] = await conn.execute('SELECT id FROM users WHERE username = ?', [username]);
    if (users.length === 0) {
      return res.status(400).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }
    const userId = users[0].id;

    // è¨ˆç®—ç¸½ç©åˆ†ï¼ˆç²å¾—ç©åˆ† - æ¶ˆè²»ç©åˆ†ï¼‰
    const [result] = await conn.execute(`
      SELECT
        COALESCE(SUM(CASE WHEN type = 'earned' THEN points ELSE 0 END), 0) -
        COALESCE(SUM(CASE WHEN type = 'spent' THEN points ELSE 0 END), 0) as total_points
      FROM point_transactions
      WHERE user_id = ?
    `, [userId]);

    res.json({ success: true, totalPoints: result[0].total_points || 0 });

  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// ===== å…Œæ›è¨˜éŒ„ç®¡ç† API =====

// ç²å–å•†å“å…Œæ›è¨˜éŒ„ï¼ˆç®¡ç†å“¡/å·¥ä½œäººå“¡ç”¨ï¼‰
app.get('/api/product-redemptions/admin', staffOrAdminAuth, async (req, res) => {
  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;
    let query, params;

    if (userRole === 'admin') {
      // ç®¡ç†å“¡å¯ä»¥çœ‹åˆ°æ‰€æœ‰å…Œæ›è¨˜éŒ„
      query = `
        SELECT pr.*, p.name as product_name, p.image_url, u.username
        FROM product_redemptions pr
        JOIN products p ON pr.product_id = p.id
        JOIN users u ON pr.user_id = u.id
        ORDER BY pr.redeemed_at DESC
      `;
      params = [];
    } else {
      // å·¥ä½œäººå“¡åªèƒ½çœ‹åˆ°è‡ªå·±ç®¡ç†çš„å•†å“çš„å…Œæ›è¨˜éŒ„
      query = `
        SELECT pr.*, p.name as product_name, p.image_url, u.username
        FROM product_redemptions pr
        JOIN products p ON pr.product_id = p.id
        JOIN users u ON pr.user_id = u.id
        WHERE p.created_by = ?
        ORDER BY pr.redeemed_at DESC
      `;
      params = [username];
    }

    const [rows] = await conn.execute(query, params);
    res.json({ success: true, redemptions: rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

// æ›´æ–°å…Œæ›è¨˜éŒ„ç‹€æ…‹
app.put('/api/product-redemptions/:id/status', staffOrAdminAuth, async (req, res) => {
  const { id } = req.params;
  const { status, notes } = req.body;

  if (!['completed', 'cancelled'].includes(status)) {
    return res.status(400).json({ success: false, message: 'ç„¡æ•ˆçš„ç‹€æ…‹' });
  }

  let conn;
  try {
    conn = await mysql.createConnection(dbConfig);
    const username = req.headers['x-username'];

    // ç²å–ç”¨æˆ¶è§’è‰²
    const [userRows] = await conn.execute(
      'SELECT role FROM users WHERE username = ?',
      [username]
    );

    if (userRows.length === 0) {
      return res.status(401).json({ success: false, message: 'ç”¨æˆ¶ä¸å­˜åœ¨' });
    }

    const userRole = userRows[0].role;

    // ç²å–å…Œæ›è¨˜éŒ„è©³æƒ…å’Œå•†å“åç¨±
    let query, params;
    if (userRole === 'admin') {
      query = `
        SELECT pr.*, p.name as product_name, p.created_by
        FROM product_redemptions pr
        JOIN products p ON pr.product_id = p.id
        WHERE pr.id = ?
      `;
      params = [id];
    } else {
      query = `
        SELECT pr.*, p.name as product_name, p.created_by
        FROM product_redemptions pr
        JOIN products p ON pr.product_id = p.id
        WHERE pr.id = ? AND p.created_by = ?
      `;
      params = [id, username];
    }

    const [redemptions] = await conn.execute(query, params);

    if (redemptions.length === 0) {
      return res.status(404).json({ success: false, message: 'å…Œæ›è¨˜éŒ„ä¸å­˜åœ¨æˆ–ç„¡æ¬Šé™è™•ç†' });
    }

    const redemption = redemptions[0];
    const productName = redemption.product_name;

    // é–‹å§‹äº¤æ˜“
    await conn.beginTransaction();

    try {
      // æ›´æ–°å…Œæ›è¨˜éŒ„ç‹€æ…‹
      await conn.execute(
        'UPDATE product_redemptions SET status = ?, notes = ? WHERE id = ?',
        [status, notes || '', id]
      );

      // å¦‚æœæ˜¯å–æ¶ˆå…Œæ›ï¼Œéœ€è¦é€€é‚„ç©åˆ†å’Œå•†å“åº«å­˜
      if (status === 'cancelled') {
        // é€€é‚„å•†å“åº«å­˜
        await conn.execute(
          'UPDATE products SET stock = stock + 1 WHERE id = ?',
          [redemption.product_id]
        );

        // è¨˜éŒ„ç©åˆ†é€€é‚„äº¤æ˜“
        await conn.execute(
          'INSERT INTO point_transactions (user_id, type, points, description, reference_type, reference_id) VALUES (?, ?, ?, ?, ?, ?)',
          [redemption.user_id, 'earned', redemption.points_used, `å–æ¶ˆå…Œæ›é€€é‚„ç©åˆ†: ${productName}`, 'redemption_cancelled', redemption.id]
        );
      }

      await conn.commit();
      res.json({ success: true, message: status === 'completed' ? 'å…Œæ›å·²å®Œæˆ' : 'å…Œæ›å·²å–æ¶ˆ' });

    } catch (err) {
      await conn.rollback();
      throw err;
    }

  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  } finally {
    if (conn) await conn.end();
  }
});

const PORT = process.env.PORT || 3001;

// catch-all route for static html (avoid 404 on /), åªé‡å°é /api/ è·¯å¾‘
app.get(/^\/(?!api\/).*/, (req, res, next) => {
  if (req.path.match(/\.[a-zA-Z0-9]+$/)) return next();
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.listen(PORT, () => {
  console.log('Server running on port ' + PORT);
}); 