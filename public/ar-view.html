<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>AR å°‹æ‰¾ç·šç´¢</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- AR.js -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        .ui-overlay {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 999;
            pointer-events: none;
        }
        .btn {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            pointer-events: auto;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        .info-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            z-index: 999;
        }
        
        #arrow-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 900;
            pointer-events: none;
            display: none;
        }
        #nav-arrow {
            width: 0; 
            height: 0; 
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 80px solid rgba(255, 0, 0, 0.8);
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
            transform-origin: center bottom;
        }
        .arrow-text {
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">

    <div class="info-box">
        <div id="status">æ­£åœ¨å®šä½ä¸­...</div>
        <div id="dist-debug" style="font-size: 1.2em; font-weight: bold; color: #ffeb3b;"></div>
        <div id="debug-log" style="font-size: 0.8em; color: #ccc;"></div>
    </div>

    <div id="arrow-container">
        <div id="nav-arrow"></div>
        <div class="arrow-text">ç›®æ¨™æ–¹å‘</div>
    </div>

    <div class="ui-overlay">
        <button id="backBtn" class="btn">ğŸ”™ è¿”å›å¡«å¯«ç­”æ¡ˆ</button>
    </div>

    <a-scene
        vr-mode-ui="enabled: false"
        embedded
        arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
        renderer="logarithmicDepthBuffer: true;" 
    >
        
        <!-- å¢åŠ ç’°å¢ƒå…‰ -->
        <a-light type="ambient" color="#ffffff" intensity="2"></a-light>

        <a-camera gps-camera rotation-reader>
            <!-- 
                ä¿éšªäºŒï¼šHUD ç´…çƒ
                ç›´æ¥æ›åœ¨ç›¸æ©Ÿä¸Šï¼Œä½ç½® z=-2 (çœ¼å‰2ç±³)
                åˆå§‹éš±è—ï¼Œè¿‘è·é›¢æ¨¡å¼æ‰æ‰“é–‹
            -->
            <a-sphere
                id="hud-sphere"
                color="red"
                radius="0.2"
                position="0 0 -2"
                material="shader: flat; opacity: 0.8"
                visible="false"
                animation="property: position; to: 0 0.1 -2; dir: alternate; dur: 1000; loop: true"
            ></a-sphere>
        </a-camera>

        <!-- 
            ä¿éšªä¸€ï¼š3D é»ƒæ–¹å¡Š (å–ä»£åŸæœ¬çš„åœ–ç‰‡)
            GPS å®šä½
        -->
        <a-box
            id="ar-box"
            color="yellow"
            scale="2 2 2"
            material="shader: flat" 
            visible="false"
            position="0 0 0" 
            animation="property: rotation; to: 0 360 0; loop: true; dur: 5000; easing: linear"
        ></a-box>

    </a-scene>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const targetLat = parseFloat(urlParams.get('lat'));
        const targetLng = parseFloat(urlParams.get('lng'));
        const taskId = urlParams.get('taskId');

        document.getElementById('backBtn').onclick = function() {
            if (taskId) {
                window.location.href = `/task-detail.html?id=${taskId}`;
            } else {
                window.history.back();
            }
        };

        if (!targetLat || !targetLng) {
            document.getElementById('status').innerText = "éŒ¯èª¤ï¼šç„¡æ•ˆçš„ä»»å‹™åº§æ¨™";
        } else {
            const arBox = document.getElementById('ar-box');
            const hudSphere = document.getElementById('hud-sphere');
            const arrowContainer = document.getElementById('arrow-container');
            const navArrow = document.getElementById('nav-arrow');
            
            let userLat = null;
            let userLng = null;
            let userHeading = 0;
            let isNearbyMode = false;

            // åˆå§‹åŒ–ï¼šæŠŠé»ƒæ–¹å¡Šæ”¾åˆ° GPS åº§æ¨™
            arBox.setAttribute('gps-entity-place', `latitude: ${targetLat}; longitude: ${targetLng};`);

            window.addEventListener('gps-camera-update-position', function(e) {
                userLat = e.detail.position.latitude;
                userLng = e.detail.position.longitude;
                
                const dist = haversineDistance(userLat, userLng, targetLat, targetLng);
                document.getElementById('dist-debug').innerText = `è·é›¢ç›®æ¨™: ${dist.toFixed(0)}m`;
                
                updateARLogic(dist);
            });

            window.addEventListener('deviceorientation', function(event) {
                if (event.webkitCompassHeading) {
                    userHeading = event.webkitCompassHeading;
                } else if (event.alpha) {
                    userHeading = 360 - event.alpha;
                }
                
                if (userLat) {
                    updateArrowRotation();
                }
            });

            function updateARLogic(dist) {
                if (dist < 15) {
                    if (!isNearbyMode) {
                        isNearbyMode = true;
                        
                        // 1. è¨ˆç®—å‰æ–¹ 3 ç±³åº§æ¨™ï¼ŒæŠŠé»ƒæ–¹å¡Šç§»éå»
                        const forwardPosition = calculateDestination(userLat, userLng, 3, userHeading);
                        arBox.setAttribute('gps-entity-place', `latitude: ${forwardPosition.lat}; longitude: ${forwardPosition.lng};`);
                        arBox.setAttribute('visible', 'true');
                        
                        // 2. é¡¯ç¤º HUD ç´…çƒ (é›™é‡ä¿éšª)
                        hudSphere.setAttribute('visible', 'true');
                        
                        // éš±è—å°èˆªç®­é ­
                        arrowContainer.style.display = 'none';
                        
                        document.getElementById('status').innerText = "ç›®æ¨™å°±åœ¨çœ¼å‰ï¼";
                        document.getElementById('debug-log').innerText = "æ¨¡å¼: 3Dæ¸¬è©¦ (é»ƒæ–¹å¡Š + ç´…çƒ)";
                    }
                } else {
                    if (isNearbyMode && dist > 20) {
                        isNearbyMode = false;
                        
                        // æ¢å¾©é è·é›¢æ¨¡å¼
                        arBox.setAttribute('gps-entity-place', `latitude: ${targetLat}; longitude: ${targetLng};`);
                        arBox.setAttribute('visible', 'true'); // é è™•ä¹Ÿé¡¯ç¤ºé»ƒæ–¹å¡Š
                        hudSphere.setAttribute('visible', 'false');
                        
                        document.getElementById('status').innerText = "è·Ÿéš¨ç®­é ­å°‹æ‰¾ç›®æ¨™";
                        document.getElementById('debug-log').innerText = "æ¨¡å¼: 3Då°èˆª";
                    }
                    
                    if (!isNearbyMode) {
                        arrowContainer.style.display = 'block';
                        document.getElementById('status').innerText = "è·Ÿéš¨ç®­é ­å°‹æ‰¾ç›®æ¨™";
                    }
                }
            }

            function updateArrowRotation() {
                if (arrowContainer.style.display === 'none') return;
                const targetBearing = calculateBearing(userLat, userLng, targetLat, targetLng);
                let arrowRotation = targetBearing - userHeading;
                navArrow.style.transform = `rotate(${arrowRotation}deg)`;
            }

            // --- æ•¸å­¸è¨ˆç®—å‡½å¼ ---
            function calculateDestination(lat, lng, distMeters, bearing) {
                const R = 6371e3;
                const angularDist = distMeters / R;
                const radLat = toRadians(lat);
                const radLng = toRadians(lng);
                const radBearing = toRadians(bearing);
                const destLat = Math.asin(Math.sin(radLat) * Math.cos(angularDist) + 
                                        Math.cos(radLat) * Math.sin(angularDist) * Math.cos(radBearing));
                const destLng = radLng + Math.atan2(Math.sin(radBearing) * Math.sin(angularDist) * Math.cos(radLat), 
                                                    Math.cos(angularDist) - Math.sin(radLat) * Math.sin(destLat));
                return { lat: toDegrees(destLat), lng: toDegrees(destLng) };
            }

            function calculateBearing(startLat, startLng, destLat, destLng) {
                const startLatRad = toRadians(startLat);
                const startLngRad = toRadians(startLng);
                const destLatRad = toRadians(destLat);
                const destLngRad = toRadians(destLng);
                const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
                const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                        Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);
                let brng = Math.atan2(y, x);
                brng = toDegrees(brng);
                return (brng + 360) % 360;
            }

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; 
                const Ï†1 = toRadians(lat1);
                const Ï†2 = toRadians(lat2);
                const Î”Ï† = toRadians(lat2 - lat1);
                const Î”Î» = toRadians(lon2 - lon1);
                const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                        Math.cos(Ï†1) * Math.cos(Ï†2) *
                        Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            function toRadians(degrees) { return degrees * Math.PI / 180; }
            function toDegrees(radians) { return radians * 180 / Math.PI; }
        }
    </script>
</body>
</html>