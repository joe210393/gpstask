<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>AR å°‹æ‰¾ç·šç´¢</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        .ui-overlay {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 999;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° AR å ´æ™¯ */
        }
        .btn {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            pointer-events: auto; /* æ¢å¾©æŒ‰éˆ•é»æ“Š */
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        .info-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            z-index: 999;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">

    <div class="info-box">
        <div id="status">æ­£åœ¨å®šä½ä¸­...</div>
        <div id="dist-debug" style="font-size: 1.2em; font-weight: bold; color: #ffeb3b;"></div>
    </div>

    <div class="ui-overlay">
        <button id="backBtn" class="btn">ğŸ”™ è¿”å›å¡«å¯«ç­”æ¡ˆ</button>
    </div>

    <a-scene
        vr-mode-ui="enabled: false"
        embedded
        arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
    >
        <a-assets>
            <img id="mascot-img" src="/images/mascot.png">
        </a-assets>

        <!-- ç›¸æ©Ÿ -->
        <a-camera gps-camera rotation-reader>
            <!-- 
                å°èˆªç®­é ­ (å›ºå®šåœ¨ç›¸æ©Ÿå‰æ–¹)
                ä½ç½®: 0 0 -2 (åœ¨é¡é ­å‰æ–¹ 2 ç±³è™•)
                åˆå§‹æ—‹è½‰: -90 0 0 (å¹³èººæŒ‡å‘å‰æ–¹)
            -->
            <a-cone
                id="guide-arrow"
                position="0 -0.5 -2" 
                rotation="90 0 0"
                radius-bottom="0.1" 
                radius-top="0" 
                height="0.3" 
                color="#ff0000"
                material="opacity: 0.8; transparent: true"
                visible="false"
            ></a-cone>
        </a-camera>

        <!-- ç›®æ¨™å¯¦é«”å°‡ç”± JS å‹•æ…‹åŠ å…¥ -->
    </a-scene>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const targetLat = parseFloat(urlParams.get('lat'));
        const targetLng = parseFloat(urlParams.get('lng'));
        const taskId = urlParams.get('taskId');

        document.getElementById('backBtn').onclick = function() {
            if (taskId) {
                window.location.href = `/task-detail.html?id=${taskId}`;
            } else {
                window.history.back();
            }
        };

        if (!targetLat || !targetLng) {
            document.getElementById('status').innerText = "éŒ¯èª¤ï¼šç„¡æ•ˆçš„ä»»å‹™åº§æ¨™";
        } else {
            const scene = document.querySelector('a-scene');

            // 1. å»ºç«‹é è™•çš„ç›®æ¨™ç‰© (å¯¶ç®±/å‰ç¥¥ç‰©)
            const targetEntity = document.createElement('a-image');
            targetEntity.setAttribute('src', '#mascot-img');
            targetEntity.setAttribute('scale', '5 5 5');
            targetEntity.setAttribute('gps-entity-place', `latitude: ${targetLat}; longitude: ${targetLng};`);
            targetEntity.setAttribute('animation', 'property: position; to: 0 1 0; dir: alternate; dur: 2000; loop: true');
            scene.appendChild(targetEntity);

            // 2. è™•ç†å°èˆªç®­é ­é‚è¼¯
            const guideArrow = document.getElementById('guide-arrow');
            let userLat = null;
            let userLng = null;
            let userHeading = 0;

            // ç›£è½ GPS æ›´æ–°
            window.addEventListener('gps-camera-update-position', function(e) {
                userLat = e.detail.position.latitude;
                userLng = e.detail.position.longitude;
                updateArrow();
                
                // è¨ˆç®—è·é›¢
                const dist = haversineDistance(userLat, userLng, targetLat, targetLng);
                document.getElementById('dist-debug').innerText = `è·é›¢ç›®æ¨™: ${dist.toFixed(0)}m`;
                
                if(dist < 20) {
                    document.getElementById('status').innerText = "ç›®æ¨™å°±åœ¨é™„è¿‘ï¼";
                    guideArrow.setAttribute('color', '#00ff00'); // é è¿‘è®Šç¶ è‰²
                } else {
                    document.getElementById('status').innerText = "è·Ÿéš¨ç´…è‰²ç®­é ­å°‹æ‰¾ç›®æ¨™";
                    guideArrow.setAttribute('color', '#ff0000');
                }
            });

            // ç›£è½æ‰‹æ©Ÿç¾…ç›¤æ–¹å‘ (DeviceOrientation)
            window.addEventListener('deviceorientation', function(event) {
                // alpha: è£ç½®ç¹ z è»¸æ—‹è½‰çš„è§’åº¦ (0-360)ï¼Œ0 ç‚ºåŒ—æ–¹
                // webkitCompassHeading: iOS å°ˆç”¨
                if (event.webkitCompassHeading) {
                    userHeading = event.webkitCompassHeading;
                } else if (event.alpha) {
                    userHeading = 360 - event.alpha;
                }
                updateArrow();
            });

            function updateArrow() {
                if (userLat === null || userLng === null) {
                    guideArrow.setAttribute('visible', 'false');
                    return;
                }

                guideArrow.setAttribute('visible', 'true');

                // 1. è¨ˆç®—ç›®æ¨™ç›¸å°æ–¼åŒ—æ–¹çš„æ–¹ä½è§’ (Bearing)
                const targetBearing = calculateBearing(userLat, userLng, targetLat, targetLng);

                // 2. è¨ˆç®—ç®­é ­æ‡‰è©²æ—‹è½‰çš„è§’åº¦
                // ç›®æ¨™æ–¹ä½ - ç”¨æˆ¶æœå‘ = ç®­é ­æ‡‰è©²åè½‰çš„è§’åº¦
                // ä¾‹å¦‚ï¼šç›®æ¨™åœ¨æ­£åŒ— (0åº¦)ï¼Œæˆ‘æœå‘æ± (90åº¦)ï¼Œç®­é ­æ‡‰è©²å¾€å·¦è½‰ 90 åº¦ (-90) æŒ‡å‘åŒ—
                let arrowRotation = targetBearing - userHeading;
                
                // A-Frame çš„æ—‹è½‰åº§æ¨™ç³»ï¼šY è»¸æ—‹è½‰
                // åŸå§‹åœ“éŒæ˜¯å¹³èººçš„ (rotation="90 0 0")
                // æˆ‘å€‘éœ€è¦è½‰å‹• Z è»¸æˆ–æ˜¯ä¿®æ­£ Y è»¸
                // é€™è£¡æˆ‘å€‘ç›´æ¥æ—‹è½‰æ•´å€‹åœ“éŒçš„ Z è»¸ (å› ç‚ºå®ƒå·²ç¶“èººä¸‹äº†)
                guideArrow.setAttribute('rotation', `90 0 ${-arrowRotation}`);
            }

            // --- è¼”åŠ©å‡½å¼ ---

            // è¨ˆç®—æ–¹ä½è§’ (Bearing)
            function calculateBearing(startLat, startLng, destLat, destLng) {
                const startLatRad = toRadians(startLat);
                const startLngRad = toRadians(startLng);
                const destLatRad = toRadians(destLat);
                const destLngRad = toRadians(destLng);

                const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
                const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                        Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);
                let brng = Math.atan2(y, x);
                brng = toDegrees(brng);
                return (brng + 360) % 360;
            }

            // Haversine è·é›¢å…¬å¼
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // metres
                const Ï†1 = toRadians(lat1);
                const Ï†2 = toRadians(lat2);
                const Î”Ï† = toRadians(lat2 - lat1);
                const Î”Î» = toRadians(lon2 - lon1);

                const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                        Math.cos(Ï†1) * Math.cos(Ï†2) *
                        Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c;
            }

            function toRadians(degrees) {
                return degrees * Math.PI / 180;
            }

            function toDegrees(radians) {
                return radians * 180 / Math.PI;
            }
        }
    </script>
</body>
</html>