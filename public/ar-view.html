<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>AR å°‹æ‰¾ç·šç´¢</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        .ui-overlay {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 999;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° AR å ´æ™¯ */
        }
        .btn {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            pointer-events: auto; /* æ¢å¾©æŒ‰éˆ•é»æ“Š */
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        .info-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            z-index: 999;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">

    <div class="info-box">
        <div id="status">æ­£åœ¨å®šä½ä¸­...</div>
        <div id="dist-debug" style="font-size: 1.2em; font-weight: bold; color: #ffeb3b;"></div>
    </div>

    <div class="ui-overlay">
        <button id="backBtn" class="btn">ğŸ”™ è¿”å›å¡«å¯«ç­”æ¡ˆ</button>
    </div>

    <a-scene
        vr-mode-ui="enabled: false"
        embedded
        arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
    >
        <a-assets>
            <img id="mascot-img" src="/images/mascot.png">
        </a-assets>

        <!-- ç›¸æ©Ÿ -->
        <a-camera gps-camera rotation-reader>
            <!-- 
                1. å°èˆªç®­é ­ (HUD)
                   æ”¹ç‚ºæ›´ç°¡å–®çš„ triangle å¹¾ä½•ï¼Œä¸¦ç¢ºä¿å®ƒåœ¨æ¥µè¿‘è·é›¢ (z=-1)
                   shader: flat ç¢ºä¿ä¸å—å…‰ç…§å½±éŸ¿
            -->
            <a-triangle
                id="guide-arrow"
                vertex-a="0 0.15 0"
                vertex-b="-0.1 -0.15 0"
                vertex-c="0.1 -0.15 0"
                position="0 -0.5 -1"
                material="color: #ff0000; shader: flat; side: double; opacity: 0.9;"
                visible="false"
            ></a-triangle>

            <!-- 
                2. è¿‘è·é›¢å¯¶ç®± (å¼·åˆ¶é¡¯ç¤º)
                   ç•¶è·é›¢ < 10m æ™‚ï¼Œæˆ‘å€‘é¡¯ç¤ºé€™å€‹ã€Œå‡ã€å¯¶ç®±
                   å®ƒå›ºå®šåœ¨ç›¸æ©Ÿå‰æ–¹ (z=-3)ï¼Œç¢ºä¿ç”¨æˆ¶ä¸€å®šçœ‹å¾—åˆ°
            -->
            <a-image
                id="nearby-target"
                src="#mascot-img"
                position="0 0 -3"
                scale="1.5 1.5 1.5"
                visible="false"
                animation="property: position; to: 0 0.2 -3; dir: alternate; dur: 1500; loop: true"
            ></a-image>
        </a-camera>

        <!-- 3. é è·é›¢å¯¶ç®± (GPS å®šä½) -->
        <!-- å°‡ç”± JS å‹•æ…‹åŠ å…¥ -->
    </a-scene>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const targetLat = parseFloat(urlParams.get('lat'));
        const targetLng = parseFloat(urlParams.get('lng'));
        const taskId = urlParams.get('taskId');

        document.getElementById('backBtn').onclick = function() {
            if (taskId) {
                window.location.href = `/task-detail.html?id=${taskId}`;
            } else {
                window.history.back();
            }
        };

        if (!targetLat || !targetLng) {
            document.getElementById('status').innerText = "éŒ¯èª¤ï¼šç„¡æ•ˆçš„ä»»å‹™åº§æ¨™";
        } else {
            const scene = document.querySelector('a-scene');

            // å»ºç«‹é è™•çš„ GPS ç›®æ¨™
            const gpsTarget = document.createElement('a-image');
            gpsTarget.setAttribute('id', 'gps-target');
            gpsTarget.setAttribute('src', '#mascot-img');
            gpsTarget.setAttribute('scale', '5 5 5');
            gpsTarget.setAttribute('gps-entity-place', `latitude: ${targetLat}; longitude: ${targetLng};`);
            gpsTarget.setAttribute('visible', 'true');
            scene.appendChild(gpsTarget);

            const guideArrow = document.getElementById('guide-arrow');
            const nearbyTarget = document.getElementById('nearby-target');
            
            let userLat = null;
            let userLng = null;
            let userHeading = 0;

            // ç›£è½ GPS æ›´æ–°
            window.addEventListener('gps-camera-update-position', function(e) {
                userLat = e.detail.position.latitude;
                userLng = e.detail.position.longitude;
                
                const dist = haversineDistance(userLat, userLng, targetLat, targetLng);
                document.getElementById('dist-debug').innerText = `è·é›¢ç›®æ¨™: ${dist.toFixed(0)}m`;
                
                updateArrowAndTarget(dist);
            });

            // ç›£è½æ‰‹æ©Ÿç¾…ç›¤æ–¹å‘
            window.addEventListener('deviceorientation', function(event) {
                if (event.webkitCompassHeading) {
                    userHeading = event.webkitCompassHeading;
                } else if (event.alpha) {
                    userHeading = 360 - event.alpha;
                }
                // å³æ™‚æ›´æ–°ç®­é ­æ—‹è½‰ (å³ä½¿ GPS æ²’æ›´æ–°)
                if (userLat) {
                    updateArrowRotation();
                }
            });

            function updateArrowAndTarget(dist) {
                if(dist < 10) {
                    // === è¿‘è·é›¢æ¨¡å¼ ===
                    document.getElementById('status').innerText = "ç›®æ¨™å°±åœ¨çœ¼å‰ï¼";
                    
                    // 1. éš±è—å°èˆªç®­é ­ (å·²ç¶“åˆ°äº†ï¼Œä¸éœ€è¦ç®­é ­)
                    guideArrow.setAttribute('visible', 'false');
                    
                    // 2. é¡¯ç¤ºã€Œè¿‘è·é›¢å¯¶ç®±ã€ (å›ºå®šåœ¨çœ¼å‰)
                    nearbyTarget.setAttribute('visible', 'true');
                    
                    // 3. éš±è—ã€ŒGPS å¯¶ç®±ã€ (é¿å…é‡è¤‡æˆ–é£„ç§»)
                    gpsTarget.setAttribute('visible', 'false');

                } else {
                    // === é è·é›¢æ¨¡å¼ ===
                    document.getElementById('status').innerText = "è·Ÿéš¨ç®­é ­å°‹æ‰¾ç›®æ¨™";
                    
                    // 1. é¡¯ç¤ºå°èˆªç®­é ­
                    guideArrow.setAttribute('visible', 'true');
                    guideArrow.setAttribute('material', 'color: #ff0000');
                    
                    // 2. éš±è—ã€Œè¿‘è·é›¢å¯¶ç®±ã€
                    nearbyTarget.setAttribute('visible', 'false');
                    
                    // 3. é¡¯ç¤ºã€ŒGPS å¯¶ç®±ã€
                    gpsTarget.setAttribute('visible', 'true');
                    
                    updateArrowRotation();
                }
            }

            function updateArrowRotation() {
                if (!guideArrow.getAttribute('visible')) return;

                const targetBearing = calculateBearing(userLat, userLng, targetLat, targetLng);
                // è¨ˆç®—ç›¸å°è§’åº¦
                let arrowRotation = targetBearing - userHeading;
                
                // æ—‹è½‰ Z è»¸ (å› ç‚ºä¸‰è§’å½¢æ˜¯å¹³é¢çš„ï¼Œæˆ‘å€‘è®“å®ƒåƒæŒ‡é‡ä¸€æ¨£è½‰)
                // 0åº¦æŒ‡å‘ä¸Šï¼Œæ‰€ä»¥æˆ‘å€‘è¦æ¸›å»æ—‹è½‰é‡
                guideArrow.setAttribute('rotation', `0 0 ${-arrowRotation}`);
            }

            // --- è¼”åŠ©å‡½å¼ ---
            function calculateBearing(startLat, startLng, destLat, destLng) {
                const startLatRad = toRadians(startLat);
                const startLngRad = toRadians(startLng);
                const destLatRad = toRadians(destLat);
                const destLngRad = toRadians(destLng);

                const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
                const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                        Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);
                let brng = Math.atan2(y, x);
                brng = toDegrees(brng);
                return (brng + 360) % 360;
            }

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; 
                const Ï†1 = toRadians(lat1);
                const Ï†2 = toRadians(lat2);
                const Î”Ï† = toRadians(lat2 - lat1);
                const Î”Î» = toRadians(lon2 - lon1);
                const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                        Math.cos(Ï†1) * Math.cos(Ï†2) *
                        Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            function toRadians(degrees) { return degrees * Math.PI / 180; }
            function toDegrees(radians) { return radians * 180 / Math.PI; }
        }
    </script>
</body>
</html>